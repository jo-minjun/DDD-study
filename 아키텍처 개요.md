# 2. 아키텍처 개요

## 1. 네 개의 영역

- 표현, 응용, 도메인, 인프라스트럭처는 아키텍처를 설계할 때 출현하는 전형적인 네가지 영역이다.
- 표현 영역
  ![6.png](./img/6.png)
  - 웹 어플리케이션에서 표현영역은 HTTP 요청을 응용 영역이 필요로 하는 형식으로 변환해서 응용 영역에 전달하고 응용 영역의 응답을 HTTP 응답으로 변환하여 전송한다.
    - 웹 브라우저가 HTTP 요청 파라미터로 데이터를 전송한다.
    - 표현 영역은 데이터를 응용 서비스가 요구하는 형식의 객체 타입으로 변환해서 전달한다.
    - 응용 서비스가 결과를 리턴한다.
    - 표현 영역은 결과를 JSON 형식으로 변환해서 HTTP 응답으로 웹 브라우저에 전송한다.
- 응용 영역
  ![7.png](./img/7.png)

  - 시스템이 사용자에게 제공해야 할 기능을 구현한다.
    - 주문 등록, 주문 취소, 상품 상세 조회 등
  - 기능을 구현하기 위해 도메인 영역의 도메인 모델을 사용한다.

    - 주문 취소 기능을 제공하는 응용 서비스를 보면 다음과 같이 주문 도메인 모델을 사용해서 기능을 구현한다.

    ```java
    public class CancelOrderService {

    	@Transactional
    	public void cancelOrder(String orderId) {
    		Order order = findOrderById(orderId);
    		if (order == null) {
    			throw new OrderNotFoundException(orderId);
    		}
    		order.cancel();
    	}
    }
    ```

    - 응용 서비스는 로직을 직접 수행하기보다는 도메인 모델에 로직 수행을 위임한다. 위 코드에서도 주문 취소 로직을 직접 구현하지 않고 Order 객체에 취소 처리를 위임하고 있다.

- 도메인 영역
  - 도메인 영역은 도메인 모델을 구현한다. 그리고 도메인 모델은 도메인의 핵심 로직을 구현한다.
    - 배송지 변경, 결제 완료, 주문 총액 계산과 같은 핵심 모델을 도메인 모델에서 구현한다.
- 인프라스트럭처 영역
  ![8.png](./img/8.png)
  - 논리적인 개념을 표현하기보다는 구현 기술에 대한 것을 다룬다.
    - RDBMS 연동 처리
    - 메시징 큐에 메시지를 송수신 기능 구현
    - 몽고DB나 레디스와의 데이터 연동을 처리
    - SMTP를 이용한 메일 발송 기능을 구현
    - HTTP 클라이언트를 이용해서 REST API를 호출
  - 표현, 응용, 도메인 영역은 구현 기술을 사용한 코드를 직접 만들지 않는다. 대신 인프라스트럭처 영역에서 제공하는 기능을 사용해서 필요한 기능을 개발한다.
    - 응용 영역에서 DB에 보관된 데이터가 필요하면 인프라스트럭처 영역의 DB 모듈을 사용하여 데이터를 읽어온다.
    - 외부에 메일을 발송해야 한다면 인프라스트럭처가 제공하는 SMTP 연동 모듈을 이용해서 메일을 발송한다.

## 2. 계층 구조 아키텍처

- 네 영역을 구성할 때 많은 사용하는 아키텍처가 아래 그림과 같은 계층 구조이다.
  ![9.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/af02c3cc-26cb-4f89-a545-f5c0832916cc/9.png)
- 계층 구조는 특성상 상위 계층에서 하위 계층으로의 의존만 존재하고 하위 계층은 상위 계층에 의존하지 않는다.
- 계층 구조를 엄격하게 적용한다면 상위 계층은 바로 아래 계층에만 의존을 가져야 하지만 구현의 편리함을 위해 계층 구조를 유연하게 적용하기도 한다.
  ![10.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/60eaa15c-9512-4ec8-b1df-00e8ff607023/10.png)
  - 응용 계층은 바로 아래 계층인 도메인 계층에 의존하지만 외부 시스템과의 연동을 위해 더 아래 계층인 인프라스트럭처 계층에 의존하기도 한다.
- 하지만 위와 계층 구조는 표현, 응용, 도메인 계층이 상세한 구현 기술을 다루는 인프라스트럭처 계층에 종속된다.

  - 도메인의 가격 계산 규칙을 예로 들어보자. Drools라는 룰 엔진을 사용해서 계산 로직을 수행하는 인프라스트럭처 영역의 코드를 만들어 본 것이다.

  ```java
  public class DroolsRuleEngine {
  	private KieContainer kContainer;

  	public DroolsRuleEngine () {
  		KieServices ks = KieServices.Factory.get();
  		kContatiner = ks.getKieClasspathContainer();
  	}

  	// 이 메서드를 이용한다.
  	public void evalute(String sessionName, List<?> facts) {
  		KieSession kSession = kContainer.newKieSession(sessionName);
  		try {
  			facts.forEach(x -> kSession.insert(x));
  			kSession.fireAllRules();
  		} finally {
  			kSession.dispose();
  		}
  	}
  }
  ```

  - 응용 영역은 가격 계산을 위해 인프라스트럭처 영역의 DroolsRuleEngine을 사용한다.

  ```java
  public class CalculateDiscountService {
  	private DroolsRuleEngine ruleEngine;

  	public CalculateDiscountService() {
  		ruleEngine = new DroolsRuleEngine;
  	}

  	public Money calculateDiscount(List<OrderLine> orderLines, String customerId) {
  		Customer customer = findCustomer(customerId);

  		MutableMoney money = new MutableMoney(0);
  		List<?> facts = Arrays.asList(customer, money);
  		facts.addAll(orderLines);
  		ruleEngine.evalute("discountCalculation", facts);
  		return money.toImmutableMoney();
  	}
  	...
  }
  ```

  - 이 코드는 두 가지 문제를 안고 있다.
  - CalculateDiscountService만 테스트하기 어렵다.
    - 이 코드를 테스트하려면 RuleEngine 완벽하게 동작해야 한다.
  - 구현 방식을 변경하기 어렵다.
    - `MutableMoney money = new MutableMoney(0);`
      - Drools의 연산 결과를 받기 위해 추가한 타입이다.
    - `List<?> facts = Arrays.asList(customer, money); `
    - `facts.addAll(orderLines);`
      - Drools 룰에 필요한 데이터이다.
    - `ruleEngine.evalute("discountCalculation", facts);`
      - Drools의 세션 이름을 넣기 위해 “discountCalculation”을 파라미터로 넘겼다.

- 이렇게 CalculateDiscountService는 Drools라는 인프라스트럭처 영역의 기술에 완전하게 의존하고 있다.
- 인프라스트럭처에 의존하면 ‘테스트 어려움’과 ‘기능 확장의 어려움’이라는 두 가지 문제가 발생하는 것을 알게 되었다. 어떻게 해야 두 문제를 해소할 수 있을까?
