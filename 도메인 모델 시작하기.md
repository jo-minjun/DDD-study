# 1. 도메인 모델 시작하기

## 1. 도메인이란?

- 개발자 입장에서 온라인 서점은 구현해야 할 소프트웨어의 대상이다. 온라인 서점은 상품 조회, 구매, 결제, 배송 추척 등의 기능을 제공해야 한다. 이때 온라인 서점은 해결하고자 하는 문제 영역, 즉 도메인에 해당한다.
- 한 도메인은 다시 하위 도메인으로 나눌 수 있다.  
  ![1.png](./img/1.png)
  - 온라인 서점 도메인은 위 그림과 같이 몇 개의 하위 도메인으로 나눌 수 있다.
  - 카탈로그 하위 도메인: 상품 목록 제공
  - 주문 하위 도메인: 고객의 주문 처리
  - 혜택 하위 도메인: 쿠폰이나 특별할인과 같은 서비스 제공
  - 배송 하위 도메인: 구매한 상품을 전달하는 일련의 과정
  - 한 하위 도메인은 다른 하위 도메인과 연동하여 완전한 기능을 제공한다.
    - 고객이 물건을 구매하면 주문, 결제, 배송, 혜택 하위 도메인의 기능이 엮인다.
- 특정 도메인을 위한 소프트웨어라고 해서 도메인이 제공해야 할 모든 기능을 직접 구현하는 것은 아니다.
  - 일부 기능은 자체 시스템으로 구현하고, 나머지 기능은 외부 업체의 시스템을 사용한다.  
    ![2.png](./img/2.png)
- 도메인마다 고정된 하위 도메인이 존재하는 것은 아니다.
  - 모든 온라인 쇼핑몰이 혜택을 제공하는 것은 아니다.
  - 소규모 쇼핑몰은 엑셀을 이용해서 수작업으로 정산을 처리한다.
- 하위 도메인을 어떻게 구성할지는 상황에 따라 달라진다.
  - 기업 고객을 대상으로 대형 장비를 판매하는 곳은 온라인으로 카탈로그를 제공하는 주문서를 받는 정도만 필요하며, 온라인 결제나 배송 추적과 같은 기능을 제공할 필요가 없다.
  - 일반 고객을 대상으로 물건을 판매한다면 카탈로그, 리뷰, 주문, 결제, 배송, 회원 기능 등이 필요하다.

## 2. 도메인 전문가와 개발자 간 지식 공유

- 온라인 홍보, 정산, 배송 등 각 영역에는 전문가가 있다. 이들은 지식과 경험을 바탕으로 본인들이 원하는 기능 개발을 요구한다.
  - 회계 담당자는 엑셀로 맞추던 정산 금액 계산을 자동화해 주는 기능을 요구할 수 있다.
- 개발자는 요구사항을 분석하고 설계하여 코드를 작성하며 테스트하고 배포한다. 이 과정에서 요구사항은 첫 단추와 같다. 첫 단추를 잘못 끼우면 모든 단추가 잘못 끼워진다.
- 도메인 전문가 만큼은 아니겠지만 이해관계자와 개발자도 도메인 지식을 갖춰야 한다. 도메인 전문가, 관계자, 개발자가 같은 지식을 공유하고 직접 소통할수록 도메인 전문가가 원하는 제품을 만들 가능성이 높아진다.

## 3. 도메인 모델

- 도메인 모델은 특정 도메인을 개념적으로 표현한 것이다.
- 주문 도메인을 생각해보자.
  - 상품을 몇개 살지 선택하고 배송지를 입력한다.
  - 선택한 상품 가격을 이용해서 총 지불 금액을 계산한다.
  - 금액 지불을 위한 결제 수단을 선택한다.
  - 주문한 뒤에도 배송 전이면 배송지 주소를 변경하거나 주문을 취소할 수 있다.
- 객체 기반 주문 도메인 모델  
  ![3.png](./img/3.png)
  - 도메인의 모든 내용을 담고 있지는 않지만 주문(Order), 주문번호(orderNumber)와 지불할 총금액(totalAmounts)이 있고, 배송정보(ShippingInfo)를 변경할 수 있음을 알 수 있다.
  - 도메인을 이해하려면 도메인이 제공하는 기능과 주요 데이터 구성을 파악해야 하는데, 기능과 데이터를 함께 보여주는 객체 모델은 도메인을 모델링하기에 적합하다.
- 상태 다이어그램 기반 주문 상태 모델  
  ![4.png](./img/4.png)
  - 이 다이어그램을 보면 상품 준비 중 상태에서 주문을 취소하면 결제 취소가 함께 이루어진다는 것을 알 수 있다.
- 도메인 모델을 표현할 때 UML 표기법만 사용해야 하는 것은 아니다. 도메인을 이해하는 데 도움이 된다면 표현 방식이 무엇인지는 중요하지 않다.
  - 관계가 중요한 경우: 그래프로 모델링
  - 계산 규칙이 중요한 경우: 수학 공식을 활용해서 모델링
- 도메인 모델은 도메인 자체를 이해하기 위한 개념 모델이다.
- 개념 모델을 이용해서 바로 코드를 작성할 수 있는 것은 아니기에 구현 모델이 따로 필요하다. 하지만 구현 모델이 개념 모델을 최대한 따르도록 할 수는 있다.
  - 객체 기반 모델 개념 모델: 객체 지향 언어를 이용해서 유사한 구현 모델을 만든다.
  - 수학적 모델 기반 개념 모델: 함수를 이용해서 유사한 구현 모델을 만든다.

### 하위 도메인과 모델

- 상술했듯 도메인은 다수의 하위 도메인으로 구성된다.
- 각 하위 도메인이 다루는 영역은 서로 다르기 때문에 같은 용어라도 하위 도메인마다 의미가 달라질 수 있다.
  - 카탈로그 도메인의 상품: 상품 가격, 상세 내용을 담고 있는 정보
  - 배송 도메인의 상품: 고객에게 실제 배송되는 물리적인 상품
- 도메인에 따라 용어의 의미가 결정되므로 여러 하위 도메인을 하나의 다이어그램에 모델링하면 안된다. 즉, 카탈로그 도메인과 배송 도메인은 모델을 따로 만들어야 한다.
- 모델의 각 구성요소는 특정 도메인으로 한정할 때 비로소 의미가 완전해진다.

## 4. 도메인 모델 패턴

- 일반적인 애플리케이션의 아키텍처는 아래 그림과 같이 네 개의 영역으로 구성된다.  
  ![5.png](./img/5.png)

| 영역                | 설명                                                                                                      |
| ------------------- | --------------------------------------------------------------------------------------------------------- |
| 표현 계층           | 사용자의 요청을 처리하고 사용자에게 정보를 보여준다. 사용자는 사람뿐만 아니라 외부 시스템일 수도 있다.    |
| 응용 계층           | 사용자가 요청한 기능을 실행한다. 업무 로직을 직접 구현하지 않으며 도메인 계층을 조합해서 기능을 실행한다. |
| 도메인 계층         | 시스템이 제공할 도메인 규칙을 구현한다.                                                                   |
| 인프라스트럭처 계층 | 데이터베이스나 메시징 시스템과 같은 외부 시스템과의 연동을 처리한다.                                      |

- 앞서 살펴본 도메인 모델이 도메인 자체를 이해하는 데 필요한 개념 모델을 의미한다면, 지금 살펴보는 도메인 모델은 아키텍처 상의 도메인 계층을 객체 지향 기법으로 구현하는 패턴을 의미한다.
- 도메인 계층은 도메인의 핵심 규칙을 구현한다.
  - 주문 도메인의 경우 **출고 전에 배송지를 변경할 수 있다**라는 규칙과 **주문 취소는 배송 전에만 할 수 있다**라는 규칙을 구현한 코드가 도메인 계층에 위치하게 된다.
- 도메인 모델 패턴은 위와 같은 예시를 객체 지향 기법으로 구현하는 패턴이다.

```java
public class Order {
	private OrderState state;
	private ShippingInfo shippingInfo;

	public void changeShippingInfo(ShippingInfo newShippingInfo) {
		if (!state.isShippingChangeable()) {
			throw new IllegalStateException("can't change shipping in " + state);
		}
		this.shippingInfo = newShippingInfo;
	}
}

public enum OrderState {
	PAYMENT_WAITING {
		public boolean isShippingChangeable() {
			return true;
		}
	}
	PREPARING {
		public boolean isShippingChangeable() {
			return true;
		}
	}
	SHIPPED, DELIVERING, DELIVERY_COMPLETED;

	public boolean isShippingChangeable() {
		return false;
	}
}
```

- 위 코드는 주문 도메인의 일부 기능을 도메인 모델 패턴으로 구현한 것이다.
- 주문 상태를 표현하는 OrderState는 배송지를 변경할 수 있는지를 검사할 수 있는 isShippingChangeable() 메서드를 제공하고 있다.
- 주문 대기 중 (PAYMENT_WAITING), 상태와 상품 준비 중 (PREPARING) 상태의 isShippingChangeable() 메서드만 true를 리턴한다.
- 즉, OrderState는 주문 대기 중이거나 상품 준비 중에는 배송지를 변경할 수 있다는 도메인 규칙을 구현하고 있다.

```java
public class Order {
	private OrderState state;
	private ShippingInfo shippingInfo;

	public void changeShippingInfo(ShippingInfo newShippingInfo) {
		if (!state.isShippingChangeable()) {
			throw new IllegalStateException("can't change shipping in " + state);
		}
		this.shippingInfo = newShippingInfo;
	}

	private boolean isShippingChangeable() {
		return state == OrderState.PAYMENT_WAITING || state == OrderState.PREPARING
	}
}

public enum OrderState {
	PAYMENT_WAITING, PREPARING,	SHIPPED, DELIVERING, DELIVERY_COMPLETED;
}
```

- 위 코드는 배송지 정보 변경 가능 여부를 판단하는 메서드를 Order로 수정한 코드이다.
- 배송지 변경 가능여부 판단 규칙이 OrderState와 다른 정보를 함께 사용한다면 OrderState만으로는 배송지 가능 여부를 판단할 수 없으므로 Order에서 로직을 구현해야 한다.
- 배송지 변경 가능 여부를 판단하는 기능이 Order에 있든 OrderState에 있든 중요한 점은 주문과 관련된 중요 업무 규칙을 주문 도메인인 Order나 OrderState에서 구현한다는 점이다.
- 핵심 규칙을 구현한 코드는 도메인 모델에만 위치하기 때문에 규칙이 바뀌거나 규칙을 확장해야 할 때 다른 코드에 영향을 덜 주고 변경 내역을 모델에 반영할 수 있게 된다.

### 개념 모델과 구현 모델

- 개념 모델은 순수하게 문제를 분석한 결과물이다. 데이터베이스, 트랜잭션 처리, 성능, 구현 기술과 같은 것을 고려하고 있지 않다. 따라서 개념 모델을 구현 가능한 형태의 모델로 전환하는 과정을 거치게 된다.
- 개념 모델을 만들 때 처음부터 완벽하게 도메인을 표현하는 모델을 만드는 시도를 할 수 있지만 이것은 불가능하다. 소프트웨어를 개발하는 동안 개발자와 관계자들은 해당 도메인을 더 잘 이해하게 된다. 따라서 시간이 지난 후 완전히 다른 의미로 해석되는 경우도 있다.
- 따라서 처음에는 전반적인 개요를 알 수 있는 수준의 개념 모델로 도메인의 전체 윤곽을 이해하는 데 집중하고, 구현하는 과정에서 개념 모델을 구현 모델로 점진적으로 발전시켜 나가야 한다.

## 5. 도메인 모델 도출

- 도메인을 모델링 도출의 기본은 핵심 구성요소, 규칙, 기능을 찾는 것이다.
- 이 과정은 요구사항에서 출발한다. 아래는 주문 도메인과 관련된 몇 가지 요구사항이다.
  - 최소 한 종류 이상의 상품을 주문해야 한다.
  - 한 상품을 한 개 이상 주문할 수 있다.
  - 총 주문 금액은 각 상품의 구매 가격 합을 모두 더한 금액이다.
  - 각 상품의 구매 가격 합은 상품 가격에 구매 개수를 곱한 값이다.
  - 주문할 때 배송지 정보를 반드시 지정해야 한다.
  - 배송지 정보는 받는 사람 이름, 전화번소, 주소로 구성된다.
  - 출고를 하면 배송지를 변경할 수 없다.
  - 출고 전에 주문을 취소할 수 있다.
  - 고객이 결제를 완료하기 전에는 상품을 준비하지 않는다.
- 다음 요구사항으로 알 수 있는 것은 주문은 ‘출고 상태로 변경하기', ‘배송지 정보 변경하기', ‘주문 취소하기', ‘결제 완료하기' 기능을 제공한다는 것이다.
  - 출고를 하면 배송지를 변경할 수 없다.
  - 출고 전에 주문을 취소할 수 있다.
  - 고객이 결제를 완료하기 전에는 상품을 준비하지 않는다.
  ```java
  public class Order {
  	public void changeShipped() {...}
  	public void changeShippingInfo(ShippingInfo newShipping) {...}
  	public void cancel() {...}
  	public void completePayment() {...}
  }
  ```
  - 상세 구현까지 할 수 있는 수준은 아니지만 Order에 관련 기능을 메서드로 추가했다.
- 다음 요구사항은 주문 항목이 어떤 데이터로 구성되는지 알려준다.
  - 한 상품을 한 개 이상 주문할 수 있다.
  - 각 상품의 구매 가격 합은 상품 가격에 구매 개수를 곱한 값이다.
  ```java
  public class OrderLine {
  	private Product product;
  	private int price;
  	private int quantity;
  	private int amounts;

  	public OrderLine(Product product, int price, int quantity) {
  		this.product = product;
  		this.price = price;
  		this.quantity = quantity;
  		this.amounts = calculateAmounts();
  	}

  	private int calculateAmounts() {
  		return price * quantity;
  	}

  	public int getAounts() {...}
  }
  ```
  - OrderLine은 적어도 주문할 상품, 상품의 가격, 구매 개수를 포함해야 한다. 추가로 각 구매 항목의 구매 가격도 제공하도록 반영했다.
- 다음 요구사항은 Order와 OrderLine과의 관계를 알려준다.
  - 최소 한 종류 이상의 상품을 주문해야 한다.
  - 총 주문 금액은 각 상품의 구매 가격 합을 모두 더한 금액이다.
  ```java
  public class Order {
  	private List<OrderLine> orderLines;
  	private Monty totalAmounts;

  	public Order(List<OrderLine> orderLines) {
  		setOrderLines(orderLines);
  	}

  	private void setOrderLines(List<OrderLine> orderLines) {
  		verifyAtLeastOneOrMoreOrderLines(orderLines);
  		this.orderLines = orderLines;
  		calculateTotalAmounts();
  	}

  	private void verifyAtLeastOneOrMoreOrderLines(List<OrderLine> orderLines) {
  		if (orderLines == null || orderLines.empty() {
  			throw new IllegalArgumentException("no OrderLine");
  		}
  	}

  	private void calculateTotalAmounts() {
  		int sum = orderLines.stream()
  												.mapToInt(x -> x.getAmount())
  												.sum();
  		this.totalAmounts = new Money(sum);
  	}

  	... // 다른 메서드들
  }
  ```
  - 한 종류 이상의 상품을 주문할 수 있으므로 Order는 최소 한 개 이상의 OrderLine을 포함해야 한다. 또한 총 주문 금액은 OrderLine의 구매 가격의 합에서 구할 수 있다.
  - 두 요구사항은 Order에 위와 같이 반영할 수 있다.
    - Order는 한 개 이상의 OrderLine을 가질 수 있으므로 Order를 생성할 때 OrderLine 목록을 List로 전달한다.
    - 생성자에서 `setOrderLines`를 호출한 뒤, `verifyAtLeastOneOrMoreOrderLines` 메서드를 통해서 제약 조건을 검사한다.
    - 또한 `calculateTotalAmounts`를 통해서 총 주문 금액을 계산한다.
- 배송지 정보는 이름, 전화번호, 주소 데이터를 가지므로 ShippingInfo 클래스를 다음과 같이 정의할 수 있다.
  ```java
  public class ShippingInfo {
  	private String receiverName;
  	private String receiverPhoneNumber;
  	private String shippingAddress1;
  	private String shippingAddress2;
  	private String shippingZipcode;

  	... 생성자, getter
  }
  ```
- 앞서 요구사항 중, ‘주문할 때 배송지 정보를 반드시 지정해야 한다'라는 내용이 있다. 이를 반영하면 Order는 다음과 같이 된다.
  ```java
  public class Order {
  	private List<OrderLine> orderLines;
  	private Monty totalAmounts;

  	public Order(List<OrderLine> orderLines, ShippingInfo shippingInfo) {
  		setOrderLines(orderLines);
  		setShippingInfo(shippingInfo);
  	}

  	private void setShippingInfo(ShippingInfo shippingInfo) {
  		if (shippingInfo == null) {
  			throw new IllegalArgumentException("no ShippingInfo");
  		}
  		this.shippingInfo = shippingInfo;
  	}

  	... // 다른 메서드들
  }
  ```
  - 생성자에서 호출하는 `setShippingInfo` 메서드는 ShippingInfo 가 null이면 Exception이 발생하는데, 이렇게 함으로써 ‘배송지 정보 필수'라는 도메인 규칙을 구현한다.
- 도메인을 구현하다 보면 특정 조건이나 상태에 따라 제약이나 규칙이 달리 적용되는 경우가 많다.
- 이 요구사항은 출고 상태가 되기 전과 후, 결제 상태의 제약 사항을 기술하고 있다.
  - 출고를 하면 배송지 정보를 변경할 수 없다.
  - 출고 전에 주문을 취소할 수 있다.
  - 고객이 결제를 완료하기 전에는 상품을 준비하지 않는다.
  ```java
  public enum OrderState {
  	PAYMENT_WAITING, PREPARING, SHIPPED, DELIVERING, DELIVERY_COMPLETED, CANCELED;
  }
  ```
  - 존재 할 수 있는 상태를 위와 같이 열거 타입으로 나타낼 수 있다.
  - 배송지 변경이나 주문 취소 기능은 출고 전에만 가능하다는 제약 규칙이 있으므로 이 규칙을 적용하기 위해 changeShippingInfo()와 cancel()은 veryfyNotYetShipped() 메서드를 먼저 실행한다.
  ```java
  public class Order {
  	private OrderState state;

  	public void changeShippingInfo(ShippingInfo newShippingInfo) {
  		verifyNotYetShipping();
  		setShippingInfo(newShippingInfo);
  	}

  	public void cancel() {
  		verifyNotYetShipping();
  		this.state = OrderState.CANCELED;
  	}

  	private void verifyNotYetShipping() {
  		if (state != OrderState.PAYMENT_WAITING && state != OrderState.PREPARING) {
  			throw new IllegalStateException("alreay shipped");
  		}
  }
  ```
  > 앞서 도메인 모델 패턴을 설명할 때는 isShippingChangeable 메서드로 제약 조건을 검사했는데, 지금은 도메인을 더 잘 알게 되었기 때문에 이름을 변경했다.
  > 최초에는 배송지 정보 변경에 대한 제약 조건만 파악했기 때문에 isShippingChangeable를 사용했지만, 요구 사항을 분석하면서 배송지 정보 변경과 주문 취소가 둘 다 ‘출고 전에 가능'하다는 제약이 있음을 알게 되었고 ‘출고 전'이라는 의미를 반영하기 위해 메서드 이름을 verifyNotYetShipping으로 변경했다.
- 지금까지 주문과 관련된 요구사항에서 도메인 모델을 점진적으로 만들어 나갔다. 일부는 구현했고, 일부는 이름 정도만 결정했다.
- 이렇게 만든 모델은 요구사항 정련을 위해 도메인 전문가나 다른 개발자와 논의하는 과정에서 공유되기도 한다.

### 문서화

- 문서화를 하는 주된 이유는 지식을 공유하기 위함이다. 구현은 코드에 있으므로 코드를 보면 다 알 수 있지만 코드는 상세한 모든 내용을 다루고 있기 때문에 코드를 이용해서 전체 소프트웨어를 분석하려면 많은 시간이 투자되어야 한다.
- 전반적인 기능 목록이나 모듈 구조, 빌드 과정은 코드를 보고 직접 이해하는 것보다 상위 수준에서 정리한 문서를 참조하는 것이 소프트웨어 전반을 빠르게 이해하는 데 도움이 되며, 세부적이거나 더 깊게 이해할 필요가 있는 부분은 코드로 분석해 나가면 된다.
- 코드를 보면서 깊게 이해하게 되므로 코드 자체도 문서화의 대상이 된다. 도메인 지식이 잘 묻어나도록 코드를 작성하지 않으면 코드의 동작 과정은 해석할 수 있어도 도메인 관점에서 왜 코드를 그렇게 작성했는지 이해하기 어렵다.
  - 즉, 코드를 뵉 좋게 작성하는 것뿐만 아니라 도메인 관점에서 코드가 도메인을 잘 표현해야 비로소 코드의 가독성이 높아지고 문서로서 코드가 의미를 같는다.
