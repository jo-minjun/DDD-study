# 4. 리포지터리와 모델 구현

## 1. JPA를 이용한 리포지터리 구현

- 이 절에서는 자바의 ORM 표준인 JPA를 이용해서 리포지터리와 애그리거트를 구현하는 방법에 대해 살펴본다.

### 1.1. 모듈 위치

- 2장에서 언급한 것처럼 리포지터리 인터페이스는 애그리거트와 같이 모데인 영역에 속하고, 리포지터리를 구현한 클래스는 인프라스트럭처 영역에 속한다.

![59.png](./img/59.png)

- 팀 표준에 따라 리포지터리 구현 클래스를 domain.impl과 같은 패키지에 위치시킬 수도 있다.
  - 하지만 이것은 리포지터리 인터페이스와 구현체를 분리하기 위한 타협안 같은 것이지 좋은 설계 원칙을 따르는 것은 아니다.
  - 가능하면 리포지터리 구현 클래스를 인프라스트럭처 영역에 위치시켜서 인프라스트럭처에 대한 의존을 낮춰야 한다.

### 1.2. 리포지터리 기본 기능 구현

- 리포지터리가 제공하는 기본 기능은 다음 두 가지다.
  - ID로 애그리거트 조회하기
  - 애그리거트 저장하기
- 두 메서드를 위한 리포지터리 인터페이스는 다음과 같은 형식을 갖는다.

```java
public interface OrderRepository {
	Order findById(OrderNo no); // Optional<Order>를 사용해도 된다.
	void save(Order order);
}
```

- 인터페이스는 애그리거트 루트를 기준으로 작성한다.
  - 주문 애그리거트는 Order 루트 엔티티를 비록해 OrderLine, Orderer, ShippingInfo 등 다양한 객체를 포함하는데, 이 구성요소 중에서 루트 엔티티인 Order를 기준으로 리포지터리를 작성한다.
- 이 인터페이스를 구현한 클래스는 JPA의 EntityManager를 이용해서 기능을 구현한다.
- 스프링 프레임워크에 기반한 리포지터리 구현 클래스는 다음과 같다.

```java
@Repository
public class JpaOrderRepository implements OrderRepository {
	@PersistenceContext
	private EntityManager entityManager;

	@Override
	public Order findById(OrderNo id) {
		return entityManager.find(Order.class, id);
	}

	@Overrid
	public void save(Order order) {
		entityManager.persist(order);
	}
}
```

### NOTE: 삭제 기능

- 삭제 요구사항이 있더라도 데이터를 실제로 삭제하는 경우는 많지 않다.
- 관리자 기능에서 삭제한 데이터까지 조회해야 하는 경우도 있고 데이터를 원복을 위해 일정 기간 동안 보관해야 할 때도 있기 때문이다.
- 이런 이유로 사용자가 삭제 기능을 실행할 때 데이터를 바로 삭제하기보다는 삭제 플래그를 사용해서 데이터를 화면에 보여줄지 여부를 결정하는 방식으로 구현한다.

## 2. 스프링 데이터 JPA를 이용한 리포지터리 구현

## 3. 매핑 구현

## 4. 애그리거트 로딩 전략

## 5. 애그리거트의 영속성 전파

## 6. 식별자 생성 기능

## 7. 도메인 구현과 DIP
