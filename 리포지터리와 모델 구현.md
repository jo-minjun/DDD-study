# 4. 리포지터리와 모델 구현

## 1. JPA를 이용한 리포지터리 구현

- 이 절에서는 자바의 ORM 표준인 JPA를 이용해서 리포지터리와 애그리거트를 구현하는 방법에 대해 살펴본다.

### 1.1. 모듈 위치

- 2장에서 언급한 것처럼 리포지터리 인터페이스는 애그리거트와 같이 모데인 영역에 속하고, 리포지터리를 구현한 클래스는 인프라스트럭처 영역에 속한다.

![59.png](./img/59.png)

- 팀 표준에 따라 리포지터리 구현 클래스를 domain.impl과 같은 패키지에 위치시킬 수도 있다.
  - 하지만 이것은 리포지터리 인터페이스와 구현체를 분리하기 위한 타협안 같은 것이지 좋은 설계 원칙을 따르는 것은 아니다.
  - 가능하면 리포지터리 구현 클래스를 인프라스트럭처 영역에 위치시켜서 인프라스트럭처에 대한 의존을 낮춰야 한다.

### 1.2. 리포지터리 기본 기능 구현

- 리포지터리가 제공하는 기본 기능은 다음 두 가지다.
  - ID로 애그리거트 조회하기
  - 애그리거트 저장하기
- 두 메서드를 위한 리포지터리 인터페이스는 다음과 같은 형식을 갖는다.

```java
public interface OrderRepository {
	Order findById(OrderNo no); // Optional<Order>를 사용해도 된다.
	void save(Order order);
}
```

- 인터페이스는 애그리거트 루트를 기준으로 작성한다.
  - 주문 애그리거트는 Order 루트 엔티티를 비록해 OrderLine, Orderer, ShippingInfo 등 다양한 객체를 포함하는데, 이 구성요소 중에서 루트 엔티티인 Order를 기준으로 리포지터리를 작성한다.
- 이 인터페이스를 구현한 클래스는 JPA의 EntityManager를 이용해서 기능을 구현한다.
- 스프링 프레임워크에 기반한 리포지터리 구현 클래스는 다음과 같다.

```java
@Repository
public class JpaOrderRepository implements OrderRepository {
	@PersistenceContext
	private EntityManager entityManager;

	@Override
	public Order findById(OrderNo id) {
		return entityManager.find(Order.class, id);
	}

	@Overrid
	public void save(Order order) {
		entityManager.persist(order);
	}
}
```

### NOTE: 삭제 기능

- 삭제 요구사항이 있더라도 데이터를 실제로 삭제하는 경우는 많지 않다.
- 관리자 기능에서 삭제한 데이터까지 조회해야 하는 경우도 있고 데이터를 원복을 위해 일정 기간 동안 보관해야 할 때도 있기 때문이다.
- 이런 이유로 사용자가 삭제 기능을 실행할 때 데이터를 바로 삭제하기보다는 삭제 플래그를 사용해서 데이터를 화면에 보여줄지 여부를 결정하는 방식으로 구현한다.

## 2. 스프링 데이터 JPA를 이용한 리포지터리 구현

- 스프링과 JPA를 함께 적용할 때는 스프링 데이터 JPA를 사용한다.
- 스프링 데이터 JPA는 지정한 규칙에 맞게 리포지터리 인터페이스를 정의하면 리포지터리를 구현한 객체를 알아서 스프링 빈으로 등록해준다.
  - 리포지터리 인터페이스를 직접 구현하지 않아도 되기 때문에 개발자는 리포지터리를 쉽게 정의할 수 있다.
- 스프링 데이터 JPA는 다음 규칙에 따라 작성한 인터페이스를 찾아서 인터페이스를 구현한 스프링 빈 객체를 자동으로 등록한다.
  - org.springframework.data.repository.Repository<T, ID> 인터페이스 상속
  - T는 엔티티 타입을 지정하고 ID는 식별자 타입을 지정
- 예를 들어 Order 엔티티 타입의 식별자가 OrderNo 타입이라고 하자.
- Order를 위한 OrderRepository는 아래와 같이 작성할 수 있다.

```java
public interface OrderRepository extends Repository<Order, OrderNo> {
	Optional<Order> findById(OrderNo id);

	void save(Order order);
}
```

- 스프링 데이터 JPA는 OrderRepository를 리포지터리로 인식해서 알맞게 구현한 객체를 스프링 빈으로 등록한다.

```java
@Service
public class CancelOrderService {
	// 빈이 주입된다.
	private OrderRepository orderRepository;

	public CancelOrderService(OrderRepository orderRepository) {
		this.orderRepository = orderRepository;
	}
	...
}
```

- 스프링 데이터 JPA를 사용하려면 지정한 규칙에 맞게 메서드를 작성해야 한다.
  - 이 장에서는 기본 규칙을 살펴보고 5장에서 추가로 더 알아볼 것이다.
- OrderRepository를 기준으로 엔티티를 저장하는 메서드는 다음 중 하나를 사용한다.
  - Order save(Order order)
  - void save(Order order)
- 식별자를 이용해서 엔티티를 조회할 때는 findById() 메서드는 사용한다.
  - Order findById(OrderNo id)
    - 엔티티가 존재하지 않으면 null을 리턴한다.
  - Optional<Order> findById(OrderNo id)
    - 엔티티가 존재하지 않으면 Optional.empty()를 리턴한다.
- 특정 프로퍼티를 이용해서 엔티티를 조회할 때는 findBy프로퍼티이름 형식의 메서드를 사용하며, 특정 Orderer 값을 갖는 Order목록을 모두 조회하는 메서드는 다음과 같이 정의할 수 있다.
  - List<Order> findAllByOrderer(Orderer orderer)
    - 이 방법은 ‘도메인 주도 개발 시작하기’ 책에는 없는 내용이지만 관례적으로 사용되기 때문에 추가했다.
  - List<Order> findByOrderer(Orderer orderer)
- 다음처럼 중첩 프로퍼티도 가능하다. 이 메서드는 Orderer 객체의 memberId 프로퍼티가 파라미터와 같은 Order 목록을 조회한다.
  - List<Order> findByOrdererMemberId(MemberId memberId)
- 엔티티를 삭제하는 메서드는 다음 두 형태를 갖는다.
  - void delete(Order order)
  - void deleteById(OrderNo id)

## 3. 매핑 구현

### 3.1. 엔티티와 밸류 기본 매핑 구현

- 애그리거트와 JPA 매핑을 위한 기본 규칙은 다음과 같다.
  - 애그리거트 루트는 엔티티이므로 @Entity로 매핑 설정한다.
- 한 테이블에 엔티티와 밸류 데이터가 같이 있다면
  - 밸류는 @Embeddable로 매핑 설정한다.
  - 밸류 타입 프로퍼티는 @Embedded로 매핑 설정한다.
- 주문 애그리거트를 예로 들어보자.
  - 애그리거트의 루트 엔티티는 Order이다.
  - 이 애그리거트에 속한 Orderer와 ShippingInfo는 밸류이다.
  - 이 세 객체와 ShippingInfo에 포함된 Address 객체와 Receiver 객체는 아래 그림처럼 한 테이블에 매핑할 수 있다.
    ![60.png](./img//60.png)
- 주문 애그리거트에서 루트 엔티티인 Order는 JPA의 @Entity로 매핑한다.
  ```java
  @Entity
  @Table(name = "purchase_order")
  public class Order {
  	...
  }
  ```
- Order에 속하는 Orderer는 밸류이므로 @Embeddable로 매핑한다.

  ```java
  @Embeddable
  public class Orderer {

  	// MemberId에 정의된 컬럼 이름을 변경하기 위해
  	// @AttributeOverride 애너테이션 사용
  	@Embedded
  	@AttributeOverrides(
  		@AttributeOverride(name = "id", column = @Column(name = "orderer_id"))
  	)
  	private MemberId memberId;

  	@Column(name = "orderer_name")
  	private String name;
  }
  ```

  - Orderer의 memberId는 Member 애그리거트를 ID로 참조한다.
  - Member의 ID 타입으로 사용되는 MemberId는 다음과 같이 id 프로퍼티와 매핑되는 테이블 컬럼 이름으로 “member_id”를 지정하고 있다.
    ```java
    @Embeddable
    public class MemberId implements Serializable {
    	@Column(name = "member_id")
    	private String id;
    }
    ```
    - 위 그림에서 Orderer의 memberId 프로퍼티와 매핑되는 컬럼 이름은 “orerer_id” 이므로 MemberId에 설정된 “member_id”와 이름이 다르다.
    - 따라서 Orderer 밸류에서 @AttributeOverrides 애너테이션을 이용해서 Orderer의 memberId 프로퍼티와 매핑할 컬럼 이름을 변경했다.

- Orderer와 마찬가지로 ShippingInfo 밸류도 또 다른 밸류인 Address와 Receiver를 포함한다.
- Address의 매핑 설정과 다른 컬럼 이름을 사용하기 위해 @AttributeOverride 애너테이션을 사용한다.

  ```java
  @Embeddable
  public class ShippingInfo {
  	@Embedded
  	@AttributeOverrides({
  		@AttributeOverride(name = "zipCode",
  											column = @Column(name = "shipping_zipcode"))
  		@AttributeOverride(name = "address1",
  											column = @Column(name = "shipping_address1"))
  		@AttributeOverride(name = "address2",
  											column = @Column(name = "shipping_address2"))
  	})
  	private Address address;

  	@Column(name = "shipping_message")
  	private String message;

  	@Embedded
  	private Receiver receiver;
  }
  ```

- 루트 엔티티인 Order 클래스는 @Embedded를 이용해서 밸류 타입 프로퍼티를 설정한다.

```java
@Entity
public class Order {
	...
	@Embedded
	private Orderer orderer;

	@Embedded
	private ShippingInfo shippingInfo;
}
```

### 3.2. 기본 생성자

- 엔티티와 밸류의 생성자는 객체를 생성할 때 필요한 것을 전달받는다.
  - Receiver 밸류 타입은 생성 시점에서 수취인의 이름과 연락처를 생성자 파라미터로 전달받는다.

```java
public class Receiver {
	private String name;
	private String phone;

	public Receiver(String name, String phone) {
		this.name = name;
		this.phone = phone;
	}
	...
}
```

- Receiver가 불변 타입이면 생성 시점에 필요한 값을 전부 전달받으므로 값을 변경하는 set 메서드를 제공하지 않는다.
- 이는 Receiver 클래스에 기본 생성자를 추가할 필요가 없다는 것을 의미한다.
- 하지만 JPA에서 @Entity와 @Embeddable로 클래스를 매핑하려면 기본 생성자를 제공해야 한다.
- DB에서 데이터를 읽어와 매핑된 객체를 생성할 때 기본 생성자를 사용해서 객체를 생성하기 때문이다.
- 이런 기술적인 제약으로 Receiver와 같은 불변 타입은 기본 생성자가 필요 없음에도 불구하고 다음과 같이 기본 생성자를 추가해야 한다.

```java
@Embeddable
public class Receiver {
	@Column(name = "receiver_name")
	private String name;
	@Column(name = "receiver_phone")
	private String phone;

	protected Receiver() {} // JPA를 적용하기 위해 기본 생성자 추가

	public Receiver(String name, String phone) {
		this.name = name;
		this.phone = phone;
	}
	...
}
```

- 기본 생성자는 JPA 프로바이더가 객체를 생성할 때만 사용한다.
- 기본 생성자를 다른 코드에서 사용하면 값이 없는 온전하지 못한 객체를 만들게 된다.
- 이런 이유로 다른 코드에서 기본 생성자를 사용하지 못하도록 protected로 선언한다.

### 3.3. 필드 접근 방식 사용

- JPA는 필드와 메서드의 두 가지 방식으로 매핑을 처리할 수 있다.
- 메서드 방식을 사용하려면 다음과 같이 프로퍼티를 위한 get/set 메서드를 구현해야 한다.

```java
@Entity
@Access(AccessType.PROPERTY)
public class Order {
	@Column(name = "state")
	@Enumerated(EnumType.STRING)
	public OrderState getState() {
		return state;
	}

	public void setState(OrderState state) {
		this.state = state;
	}
	...
}
```

- 엔티티에 프로퍼티를 위한 공개 get/set 메서드를 추가하면 도메인의 의도가 사라지고 객체가 아닌 데이터 기반으로 엔티티를 구현할 가능성이 높아진다.
- 특히 set 메서드는 내부 데이터를 위부에서 변경할 수 있는 수단이 되기 때문에 캡슐화를 깨는 원인이 될 수 있다.
  - 도메인의 의도가 잘 드러나도록 setState()보다는 cancel()을 권장한다.
- 밸류 타입을 불변으로 구현하려면 set 메서드 자체가 필요 없는데 JPA의 구현 방식 때문에 공개 set 메서드를 추가하는 것도 좋지 않다.
- 객체가 제공할 기능 중심으로 엔티티를 구현하게끔 유도하려면 JPA 매핑 처리를 프로퍼티 방식이 아닌 필드 방식으로 선택해서 불필요한 get/set 메서드를 구현하지 말아야 한다.

```java
@Entity
@Access(AccesType.FIELD)
public class Order {

	@EmbeddedId
	private OrderNo number;

	@Column(name = "state")
	@Enumberated(EnumType.STRING)
	private OrderState state;

	... // cancel(), changeShippingInfo() 등 도메인 기능 구현
	... // 필요한 get 메서드 제공
}
```

## 4. 애그리거트 로딩 전략

## 5. 애그리거트의 영속성 전파

## 6. 식별자 생성 기능

## 7. 도메인 구현과 DIP
