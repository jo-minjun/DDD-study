# 4. 리포지터리와 모델 구현

## 1. JPA를 이용한 리포지터리 구현

- 이 절에서는 자바의 ORM 표준인 JPA를 이용해서 리포지터리와 애그리거트를 구현하는 방법에 대해 살펴본다.

### 1.1. 모듈 위치

- 2장에서 언급한 것처럼 리포지터리 인터페이스는 애그리거트와 같이 모데인 영역에 속하고, 리포지터리를 구현한 클래스는 인프라스트럭처 영역에 속한다.

![59.png](./img/59.png)

- 팀 표준에 따라 리포지터리 구현 클래스를 domain.impl과 같은 패키지에 위치시킬 수도 있다.
  - 하지만 이것은 리포지터리 인터페이스와 구현체를 분리하기 위한 타협안 같은 것이지 좋은 설계 원칙을 따르는 것은 아니다.
  - 가능하면 리포지터리 구현 클래스를 인프라스트럭처 영역에 위치시켜서 인프라스트럭처에 대한 의존을 낮춰야 한다.

### 1.2. 리포지터리 기본 기능 구현

- 리포지터리가 제공하는 기본 기능은 다음 두 가지다.
  - ID로 애그리거트 조회하기
  - 애그리거트 저장하기
- 두 메서드를 위한 리포지터리 인터페이스는 다음과 같은 형식을 갖는다.

```java
public interface OrderRepository {
	Order findById(OrderNo no); // Optional<Order>를 사용해도 된다.
	void save(Order order);
}
```

- 인터페이스는 애그리거트 루트를 기준으로 작성한다.
  - 주문 애그리거트는 Order 루트 엔티티를 비록해 OrderLine, Orderer, ShippingInfo 등 다양한 객체를 포함하는데, 이 구성요소 중에서 루트 엔티티인 Order를 기준으로 리포지터리를 작성한다.
- 이 인터페이스를 구현한 클래스는 JPA의 EntityManager를 이용해서 기능을 구현한다.
- 스프링 프레임워크에 기반한 리포지터리 구현 클래스는 다음과 같다.

```java
@Repository
public class JpaOrderRepository implements OrderRepository {
	@PersistenceContext
	private EntityManager entityManager;

	@Override
	public Order findById(OrderNo id) {
		return entityManager.find(Order.class, id);
	}

	@Overrid
	public void save(Order order) {
		entityManager.persist(order);
	}
}
```

### NOTE: 삭제 기능

- 삭제 요구사항이 있더라도 데이터를 실제로 삭제하는 경우는 많지 않다.
- 관리자 기능에서 삭제한 데이터까지 조회해야 하는 경우도 있고 데이터를 원복을 위해 일정 기간 동안 보관해야 할 때도 있기 때문이다.
- 이런 이유로 사용자가 삭제 기능을 실행할 때 데이터를 바로 삭제하기보다는 삭제 플래그를 사용해서 데이터를 화면에 보여줄지 여부를 결정하는 방식으로 구현한다.

## 2. 스프링 데이터 JPA를 이용한 리포지터리 구현

- 스프링과 JPA를 함께 적용할 때는 스프링 데이터 JPA를 사용한다.
- 스프링 데이터 JPA는 지정한 규칙에 맞게 리포지터리 인터페이스를 정의하면 리포지터리를 구현한 객체를 알아서 스프링 빈으로 등록해준다.
  - 리포지터리 인터페이스를 직접 구현하지 않아도 되기 때문에 개발자는 리포지터리를 쉽게 정의할 수 있다.
- 스프링 데이터 JPA는 다음 규칙에 따라 작성한 인터페이스를 찾아서 인터페이스를 구현한 스프링 빈 객체를 자동으로 등록한다.
  - org.springframework.data.repository.Repository<T, ID> 인터페이스 상속
  - T는 엔티티 타입을 지정하고 ID는 식별자 타입을 지정
- 예를 들어 Order 엔티티 타입의 식별자가 OrderNo 타입이라고 하자.
- Order를 위한 OrderRepository는 아래와 같이 작성할 수 있다.

```java
public interface OrderRepository extends Repository<Order, OrderNo> {
	Optional<Order> findById(OrderNo id);

	void save(Order order);
}
```

- 스프링 데이터 JPA는 OrderRepository를 리포지터리로 인식해서 알맞게 구현한 객체를 스프링 빈으로 등록한다.

```java
@Service
public class CancelOrderService {
	// 빈이 주입된다.
	private OrderRepository orderRepository;

	public CancelOrderService(OrderRepository orderRepository) {
		this.orderRepository = orderRepository;
	}
	...
}
```

- 스프링 데이터 JPA를 사용하려면 지정한 규칙에 맞게 메서드를 작성해야 한다.
  - 이 장에서는 기본 규칙을 살펴보고 5장에서 추가로 더 알아볼 것이다.
- OrderRepository를 기준으로 엔티티를 저장하는 메서드는 다음 중 하나를 사용한다.
  - Order save(Order order)
  - void save(Order order)
- 식별자를 이용해서 엔티티를 조회할 때는 findById() 메서드는 사용한다.
  - Order findById(OrderNo id)
    - 엔티티가 존재하지 않으면 null을 리턴한다.
  - Optional<Order> findById(OrderNo id)
    - 엔티티가 존재하지 않으면 Optional.empty()를 리턴한다.
- 특정 프로퍼티를 이용해서 엔티티를 조회할 때는 findBy프로퍼티이름 형식의 메서드를 사용하며, 특정 Orderer 값을 갖는 Order목록을 모두 조회하는 메서드는 다음과 같이 정의할 수 있다.
  - List<Order> findAllByOrderer(Orderer orderer)
    - 이 방법은 ‘도메인 주도 개발 시작하기’ 책에는 없는 내용이지만 관례적으로 사용되기 때문에 추가했다.
  - List<Order> findByOrderer(Orderer orderer)
- 다음처럼 중첩 프로퍼티도 가능하다. 이 메서드는 Orderer 객체의 memberId 프로퍼티가 파라미터와 같은 Order 목록을 조회한다.
  - List<Order> findByOrdererMemberId(MemberId memberId)
- 엔티티를 삭제하는 메서드는 다음 두 형태를 갖는다.
  - void delete(Order order)
  - void deleteById(OrderNo id)

## 3. 매핑 구현

## 4. 애그리거트 로딩 전략

## 5. 애그리거트의 영속성 전파

## 6. 식별자 생성 기능

## 7. 도메인 구현과 DIP
